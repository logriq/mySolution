#include <iostream>
#include <string>

// 1. Що таке хеш-таблиця.

/*
Хеш-таблиця - це абстрактна структура даних, яка швидко надає дані по ключу незалежно від кількості даних. Швидко - це зазвичай O(1).

Кожний елемент хеш-таблиці - це пара з ключа і значення. Ви шукаєте певні значення по ключу. Ключ, як і значення, може бути любого типу даних.
*/
// 2. Що таке хеш-функція.

// Хеш-функція - це функція, яка приймає ключ і перетворює його в значення завдяки
// певному алгоритму. Якому - вирішуєте ви.

// Приклад хеш-функції:

unsigned int countOfElements = 5;

unsigned int Hash(const std::string& key)
{
    // Індекси всіх символів рядка добавити між собою і розділити по модулю на кількість елементів хеш-таблиці
    unsigned int sum = 0;
    for (size_t i = 0; i < key.length(); i++)
    {
        sum += static_cast<int>(key[i]);
    }

    return sum % countOfElements;
}

void TestMyHash()
{
    std::cout << Hash("Frog") << std::endl; // 3
    std::cout << Hash("Dog") << std::endl; // 2
    std::cout << Hash("Cat") << std::endl; // 0
}

//Колізія - коли стикається 2 ключі

// 3. Метод відкритої адресації

/*1. Метод відкритої адресації : якщо є колізія - записати ключ в наступний індекс.Якщо наступний зайнятий - записати в ще наступний.І так далі.
Причому поняття "записати в наступний індекс" не означає зробити щось наподобі "теперішній_індекс + 1". Це може й означати "знову найти хеш від ключа", 
якщо хеш - поверне інше число.
І так постійно. Цей процес пошуку правильного індексу називається "пробування".Результат таких хешів називається "проба".У цього методу є деякі мінуси :
-Залежність від способу обходу : напишете фіговий хеш, то пробування буде тривати дуже довго
- Залежність від розміру внутрішнього масиву : створите замалий масив - прийдеться переписувати всю таблицю.
Створите завеликий - забагато пам'яті буде непотрібною

Але є плюси:
- Швидкий обхід по таблиці: всі елементи можуть лежать поряд, в звичайному масиві.
- Менші витрати на пам'ять по елементам: кожний елемент буде мати тип ключа, а не тип списку, як в наступному методі

Виникає питання:
Що робити, якщо таблиця уже заповнена - в такому випадку треба добавити перевірку на те, чи таблиця уже повністю зайнята і якщо так 
- створити нову таблицю з більшою кількістю елементів (проводьте аналогію з додаванням нового елементу в контейнер
std::vector у якого size == capacity)
*/

// 4. Метод ланцюжків

/*2. Метод ланцюжків : елементи в таблиці являються списками, наприклад об'єктами контейнеру std::list.Якщо ми додаємо новий елемент і його немає в таблиці,
то він просто додається, як перший елемент std::list. Якщо ми додаємо новий елемент, який уже є в нашій таблиці, то ми додаємо його в той же об'єкт std::list,
тільки як другий елемент.У цього методу є деякі мінуси :
-Оскільки кожний елемент таблиці - це список, то й пам'яті це займає більше, чим в першому методі.
- Обхід по хеш - таблиці повільніший, чим в першому методі : із - за того, що може треба буде проходитися по всім елементам конкретного списку

Але є плюси : Просто реалізовувати
*/

// 5. Властивості хорошої хеш-функції

/*
хеш-функція - чим кращий її алгоритм, тим менше колізій буде і тим швидше ми отримаємо необхідне нам значення. Хороша функція має мати наступні 4 властивості:
1. Детермінізм - для одного і того самого ключа завжди має видаватися одне і те саме значення.
2. Рівномірність - функція для кожного ключа має видавати інше значення. В ідеалі це не можливо,
бо кількість елементів в теорії може бути безкінечна, але до цього треба прагнути.
3. Ефективність - функція має швидко рахувати значення по ключу.
4. Обмеженість - функція має видавати індекси, які будуть знаходитися в межах таблиці
*/

// 6. Реалізація власного класу HashTable

template <typename Key, typename Value>
class HashTable
{
private:
    struct Node
    {
        Key key;
        Value value;
        std::unique_ptr<Node> next;
    };

    size_t m_size;
    Node** m_table;
    size_t HashFunction(const Key& key) const
    {
        return std::hash<Key>()(key) % m_size;
    }
public:
    HashTable(size_t size = 10)
        :m_size(size)
        , m_table(new Node* [size] {})

        HashTable(const HashTable&) = delete;
    HashTable& operator=(const HashTable&) = delete;

    ~HashTable()
    {
        Clear();
        delete[] m_table;
    }

}