def quick_sort(arr) :
    //Функція реалізує алгоритм швидкого сортування(QuickSort).
    //Основна ідея : вибрати опорний елемент(pivot), розбити масив на дві частини :
//1) елементи, які менші за опорний,
//2) елементи, які більші або рівні опорному.
//Потім рекурсивно застосувати швидке сортування до цих двох частин.

//Часова складність алгоритму :
//-Середній та найкращий випадки : O(n log n)
//- Найгірший випадок(коли обирається найменший або найбільший елемент) : O(n?)

//Просторова складність : O(n) у випадку використання списків Python через створення нових списків.

//Базовий випадок : якщо довжина масиву менше або дорівнює 1, він уже відсортований

if len(arr) <= 1 :
    return arr

//Вибір опорного елемента(pivot) - тут вибираємо середній елемент масиву

    pivot = arr[len(arr)2]  

//Розбиття масиву :
// Всі елементи, менші за pivot, потрапляють у left

left = [x for x in arr if x < pivot]

// Всі елементи, рівні pivot, потрапляють у middle

    middle = [x for x in arr if x == pivot]

// Всі елементи, більші за pivot, потрапляють у right

    right = [x for x in arr if x > pivot]

//Рекурсивне сортування підмасивів та об'єднання результату

    return quick_sort(left) + middle + quick_sort(right)

//Приклад використання швидкого сортування
    
arr = [3, 6, 8, 10, 1, 2, 1, 5, 7, 4, 9]

    sorted_arr = quick_sort(arr)

    print("Вхідний масив:", arr)

    print("Відсортований масив:", sorted_arr) // Виведе відсортований масив




        





        //Алгоритм сортування злиттям



 def merge_sort(arr) :
        if len(arr) <= 1 :
            return arr  // Базовий випадок : якщо масив має один або нуль елементів, він вже впорядкований

            mid = len(arr) // 2   Ділимо масив навпіл
            left_half = merge_sort(arr[:mid])  // Рекурсивно сортуємо ліву частину
            right_half = merge_sort(arr[mid:])  // Рекурсивно сортуємо праву частину

            return merge(left_half, right_half)  // Об'єднуємо відсортовані частини

            def merge(left, right) :
            sorted_arr = []  // Тут збиратиметься остаточно відсортований масив
            i = j = 0  // Лічильники для проходу по лівій і правій частинах

            while i < len(left) and j < len(right) : // Порівнюємо елементи з двох частин
                if left[i] < right[j]:  // Менший елемент йде в результат
                    sorted_arr.append(left[i])
                    i += 1
                else:
    sorted_arr.append(right[j])
        j += 1

        sorted_arr.extend(left[i:])  // Додаємо залишки, якщо в лівій частині ще є елементи
        sorted_arr.extend(right[j:])  // Додаємо залишки, якщо в правій частині ще є елементи

        return sorted_arr

// Є масив чисел, наприклад, без порядку.Алгоритм сортування злиттям його впорядкує

        arr1 = [38, 27, 43, 3, 9, 82, 10]
        print(merge_sort(arr1))  # Вихід: [3, 9, 10, 27, 38, 43, 82]

// Якщо вхідний масив містить повторювані елементи, алгоритм все одно правильно працює

        arr2 = [4, 2, 4, 3, 2, 1]
        print(merge_sort(arr2))  # Вихід: [1, 2, 2, 3, 4, 4]

// Якщо масив вже впорядкований, сортування просто підтвердить це

        arr3 = [1, 2, 3, 4, 5]
        print(merge_sort(arr3))  # Вихід: [1, 2, 3, 4, 5]

// Якщо масив упорядкований у зворотному порядку, алгоритм його перевпорядкує

        arr4 = [100, 50, 25, 12, 6, 3, 1]
        print(merge_sort(arr4))  # Вихід: [1, 3, 6, 12, 25, 50, 100]

// Якщо масив порожній, він залишиться таким самим

        arr5 = []
        print(merge_sort(arr5))  # Вихід: []

 // Якщо в масиві один елемент, він вже відсортований

        arr6 = [42]
        print(merge_sort(arr6))  # Вихід: [42]

// Якщо в масиві присутні однакові значення, алгоритм не змінює їх порядок відносно одне одного(стабільність сортування)

        arr7 = [5, 2, 9, 1, 5, 6]
        print(merge_sort(arr7))  # Вихід: [1, 2, 5, 5, 6, 9]

